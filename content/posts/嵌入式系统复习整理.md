---
title: 嵌入式系统复习整理
date: 2018-01-17T14:59:06+08:00
tags: ["嵌入式"]
category: ["技术"]
---

# 第一部分-概述(侧重概念)

1. 嵌入式系统三要素：嵌入性、专用性、计算机。(软件+硬件)
   	特点：专用性、小型化(资源有限)、软硬件一体设计、需要交叉开发环境
      	微控制器——存储器在片内;微处理器——存储器在片外

2. 嵌入式系统软件一般由嵌入式操作系统和应用软件组成;操作系统是连接计算机硬件与应用程序的系统程序
   	实时性分类为：非实时操作系统(如Linux等)、实时操作系统(RTOS)

3. 嵌入式的应用：工业控制、交通管理、信息家电、家庭智能管理系统，POS网络及电子商务，电子政务，环境检测，机器人

4. 冯诺依曼体系和哈佛体系的区别：使用两个独立的存储器模块，分别存储指令和数据|使用独立的两条总线，分别作为CPU与每个存储器之间的专用通信路径，这两条总线之间毫无关联;一般冯·诺依曼结构采用统一Cache，一般哈佛结构采用独立Cache

5. 流水线技术--指令可以并行执行，提高CPU运行效率、内部信息流要求通畅流动

6. RISC指令特点：硬连线的指令译码逻辑、减少指令和寻址方式的种类、大多数指令单周期执行、分开的Load/Store结构的存取指令、固定指令格式

7. RISC复杂在编译器，一个周期执行一条指令，指令长度固定;
   	优势：处理器管芯面积小、开发时间少成本低、易高性能。缺点：代码密度低(需要大存储器空间)、不能执行X86代码、优化编译程序困难
      	CISC复杂在处理器，指令长度不固定

8. 嵌入式系统的基本设计过程：需求分析、规格说明、体系结构设计、硬件构件软件构件、系统调试与集成
   可移植操作系统接口--POSIX--Portable Operating System Interface of UNIX

# 第二部分-ARM = Advanced RISC  Machines

1. Thumb技术特点：支持Thumb的核有2套独立的指令集、ARM32位指令的性能、Thumb16位的代码密度、性能和代码密度均衡
2. ARM状态处理器执行32位的字对齐的ARM指令，开始执行代码时、执行异常处理时应该处于ARM状态;
      	Thumb状态处理器执行16位的、半字对齐的 Thumb 指令。
      	程序执行过程中可随时切换。操作数寄存器的状态位(位0)为1，BX指令 ARM->Thumb
3. ARM中"字"是32bit(32位),半字16bit，字节8bit
4. 用户模式(Usr)：用于正常执行程序
   快速中断模式(FIQ)：用于高速数据传输
   外部中断模式(IRQ)：用于通常的中断处理
   管理模式(svc)：操作系统使用的保护模式
   数据访问终止模式(abt)：当数据或指令预取终止时进入该模式，可用于虚拟存储以及存储保护
   系统模式(sys)：运行具有特权的操作系统任务
   未定义指令中止模式(und)：当未定义的指令执行时进入该模式，可用于支持硬件
   除了用户模式外，其它都是特权模式。除了系统模式外的特权模式是异常模式。异常模式主要处理中断和异常
5. 37个32 位长的寄存器，不能被同时访问
   1个用作PC（program counter）;
   30个用作一般通用寄存器;
   1个用作CPSR(current program status register);
   5个用作SPSR(saved program status registers)
   R0～R7为未分组的寄存器，R8～R14为分组寄存器
   R8～R12有两个分组的物理寄存器。一个用于除FIQ模式之外的所有寄存器模式，另一个用于FIQ模式。发生FIQ中断后可加速FIQ的处理速度
   寄存器R13、R14分别有6个分组的物理寄存器。一个用于用户和系统模式，其余5个分别用于5种异常模式
   R13常作为堆栈指针(SP)
   R14为链接寄存器(LR)在结构上有两个特殊功能：每种模式R14用于保存子程序返回地址、发生异常R14设置为异常返回地址。用BL或BLX指令调用子程序时，指令先将下一条指令的PC值拷贝给R14
   R15为程序计数器(PC)，PC的值为当前指令的地址值加8个字节
   R16为当前程序状态寄存器CPSR(Current Program Status Register)备份的程序状态寄存器SPSR(Saved Program Status Register)异常发生时，SPSR用于保存CPSR的值，从异常退出时则可由SPSR来恢复CPSR
   Thumb状态下：R0~R7/PC/SP/LR/CPSR
6. 异常响应过程：PC->LR，CPSR->SPSR，根据异常类型，强制设置CPSR的运行模式位，跳转到相应的异常处理程序处
   异常处理过后：LR-减去一个常量->PC，SPSR->CPSR

# 第三部分-ARM汇编

1. 带S的(如ADDS)都会影响CPSR

2. 每个立即数都由一个8位常数循环右移偶数位得到
   逻辑移位都补0，算术右移补最高位，只有循环右移没有循环左移，RRX连同C标志循环右移一位
   ADD	R3，R2，R1，LSR	#2  R3=R2+R1/4
   
3. U控制位为1时加上偏移量;U控制位为0时减去偏移量
   事先更新方式：[R1,#4]！
   事后更新方式：[R1],#4
   
4. 块拷贝寻址是多寄存器传送指令LDM/STM的寻址方式
   ARM指令中的堆栈形式STMFD/LDMFD  SP！	{R1-R7，LR}	注：一定要带有！
   Thumb指令中的堆栈形式PUSH/POP	 {R1-R7，LR}
   B[L]->[将下一条指令的地址拷贝到链接寄存器(R14/LR)]中跳转到指定的地址执行程序
   BX[L]->带[连接和]状态切换的跳转指令注：跳转的范围是±32MB，寻址方式：相对寻址
   CPSR的第5位T，若T置位，则认为指令流为16位的Thumb指令;否则为标准的ARM指令。只有在命名中有字母T的ARM处理器才支持Thumb指令

5.	...
    
    1. BGLS(A/L) test1--定义全局变量。LCLS--定义局部变量
       test1 SETS(A/L)----赋值
    2. Reglist RLIST {R0-R5,R8,R10} 定义寄存器列表
    3. LTORG声明一个数据缓冲(literal pool)的开始
    4. MAP 0x100,R0定义结构化内存表首地址的值为0x100＋R0 MAP=^ FIELD=# 都仅用于定义数据结构，并不实际分配存储单元
    5. DataSpace  SPACE  100分配连续100字节的存储单元并初始化为0 SPACE=%
    6. Str DCB "This is a test!"分配一片连续的字节存储单元并初始化 DCB==
    7. DataTest DCW 1,2,3分配一片连续的半字存储单元并初始化(DCWU不要求半字对齐) DCD=&
    8. AREA Init,CODE,READONLY,ALIEN=3指定后面的指令为8字节对齐
    9. EQU=*
    10. EXPORT声明一个全局的标号，该标号可在其他的文件中引用
        IMPORT通知编译器要使用的标号在其他的源文件中定义，但要在当前源文件中引用(无论用不用都会加入当前源文件符号表，与extern区别)
        可以使用INCLUDE代替GET
    11. start	MOV R0,#0
        ADR R1,start  -->变为SUB R1,pc,#0xC
    12. BL指令完成两个操作：将返回地址放在LR寄存器中、将PC寄存器值设置成目标子程序的首地址
        存储器最基本的参数是容量和数据宽度
        Nor Flash读速度快，用来存储代码;Nand Flash常用来存储数据
        嵌入式软件的特性：规模小，开发难度大/快速启动，直接运行/实时性和可靠性要求高/开发平台和运行平台各不相同
        软实时RTOS:嵌入式Linux/WinCE,硬实时RTOS:VxWorks/OSE/Nuclear,著名的open RTOS:uC/OS/TEMS,自主知识产权的RTOS:HOPEN/Delta OS

# 第四部分-UC/OS

1. UC/OS–II 2.5版本支持最多64个任务。每个任务有一个特定的优先级，优先级越高，其数值越小
   运行状态：运行、就绪、挂起、中断、休眠

2. 系统设计：需求分析->总体设计->硬件开发及过程控制/代码生成->系统联调/程序固化

   ```asm
   AREA  Block，CODE，READONLY ;设置本段程序的名						;称（Block）及属性
   num	EQU  20	   ;设置将要复制的字数
   		ENTRY      	   ;标识程序入口点
   Start	LDR  r0，=src  ;r0寄存器指向源数据区src
   		LDR  r1，=dst  ;r1寄存器指向目标数据区dst
   		MOV  r2;#num ;r2指定将要复制的字数
   		MOV  sp，#0x400 ;设置数据栈指针（r13），
   				 ;用于保存工作寄存器数值
   Blockcopy            	;进行以8个字为单位的数据复制
     		MOVS  r3，r2，LSR ＃3 ;需要进行的以8个字
   					;为单位的复制次数
   		BEQ   Copywords 	;对于剩下不足8个字的数据，
   					;跳转到copywords，以字为单位复制
      	STMFD  sp!，｛r4-r11｝;保存工作寄存器
   
   Octcopy
   		LDMIA  r0!，｛r4-r11｝;从源数据区读取8个字的数据， 
   				;放到8个寄存器中，并更新源数据区指针r0
   		STMIA  r1!，｛r4-r11｝;将这8个字数据写入到目标数据
   					;区中，并更新目标数据区指针r1
   		SUBS  r3，r3，#1      ;将块复制次数减1
   		BNE   Octcopy    ;循环，直到完成以8个字为单位的块复制
   		LDMFD  sp!，{r4-r11}  ;恢复工作寄存器值
   Copywords
   		ANDS  r2，r2，#7       ;剩下不足8个字的数据的字数
   		BEQ   Stop             ;数据复制完成
   Wordcopy
   		LDR   r3，[r0]，＃4 ;从源数据区读取1个字的数据，
   				;放到r3寄存器中并更新目标数据区指针r0
   		
   		STR  r3，［r1］，＃4 	;将这r3中数据写入到目标数据区中，
   					;并更新目标数据区指针r1
   		SUBS r2，r2，＃l 	;将字数减l
   		BNE  Wordcopy   	;循环，直到完成以字为单位的数据复制
   Stop	MOV  r0， #0x18	;程序退出
   		LDR  r1，=0x20026
   		SWI  0x123456
   
   		AREA  BlockData ，DATA，READWRITE ;定义数据区
   Src	DCD  1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4  ;定义源数据区src
   Dst	DCD  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0  ;定义目标数据区dst
   		END  			;结束汇编
   
   
   AREA  Jump，CODE，READONLY 		;设置本段程序的
   									;名称（Jump）及属性
   num	EQU  2 							;跳转表中的子程序个数
   		ENTRY        				;程序执行的入口点
   Start
   		MOV   r0，#0 				;设置3个参数，然后调用子程序										;arithfunc，进行算术运算
   		MOV   r1，#3 
   		MOV   r2，#2
   		BL    arithfunc  				;调用子程序arithfunc
   Stop									;程序退出
   		MOV  r0， #0x18
   		LDR  r1，=0x20026
   		SWI  0x123456
   Arithfunc			  					;子程序arithfunc入口点
   		CMP   	r0，#num      	  	;判断选择子程序的参数是否在
   					  				;有效范围之内
   		MOVHS 	pc，lr   	  		;若不在，则直接返回
   		ADR		r3，JumpTable   	;读取跳转表的基地址（ADR是伪指令）
   		LDR		pc，[r3，r0，LSL #2] 	;根据参数r0的值跳转到
   									;相应的子程序
   JumpTable
   		DCD		DoAdd
   		DCD		DoSub
   DoAdd    							;子程序DoAdd执行加法操作
    		ADD	r0，r1，r2
    		MOV	pc，lr
   DoSub 								;子程序DoSub执行减法操作
    		SUB	r0，r1，r2
   		MOV	pc，lr
   		END           				;结束汇编
   ```